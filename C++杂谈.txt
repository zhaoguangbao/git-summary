C++杂谈
1.语言背后是实现，从设计实现的角度去理解语言特性及语法。
2.语法的存在是为了理解，相较于人的理解更偏向于机器的理解，语言的解释需要经由编译器，而编译器的规则是人制定的，
所以可以在理解的基础上记忆相关语法。
3.随着程序规模的扩大，并行开发以及局部模块开发是必然的，C++命名空间的存在一方面就是为了这种局部化，
其中匿名命名空间更为体现了这一原则，将变量局部在了一个编译单元内，这使得在没法获得全局意识的前提下，安全可靠的编程，
当然这也便于模块化编程的实现，模块化则必然有利于并行开发、多人合作开发。
4.简单面向对象编程思想的理解，构造事物帮你完成一项工作。
5.为了达到举一反三的效果，C++添加了模板属性。




一、C++内存分配
1.new运算符和operator new()介绍
new：是运算符，不可重载，比如A* a = new A;  对于new来说，有new和::new之分，前者位于std
operator new()：是函数，对于operator new来说，分为全局重载和类重载，全局重载是void* ::operator new(size_t size)
在类中重载形式 void* A::operator new(size_t size)。operator new()完成的操作一般只是分配内存，事实上系统默认的全局::operator new(size_t size)也只是调用malloc分配内存，并且返回一个void*指针，而构造函数的调用是在new运算符中完成的。

2.new和operator new之间的关系
A* a = new A；
这里分为两步：
  1.分配内存
  2.调用A()构造对象
分配内存这一操作就是由operator new(size_t)来完成的，如果类A重载了operator new，那么将调用A::operator new(size_t )，如果没有重载，就调用::operator new(size_t )，全局new操作符由C++默认提供。
因此前面的两步也就是：
  1.调用operator new 
  2.调用构造函数
  
（1）new ：不能被重载，其行为总是一致的。它先调用operator new分配内存，然后调用构造函数初始化那段内存。
new 操作符的执行过程：
  1. 调用operator new分配内存
  2. 调用构造函数生成类对象
  3. 返回相应指针
  
（2）operator new：要实现不同的内存分配行为，应该重载operator new，而不是new。
operator new就像operator + 一样，是可以重载的。如果类中没有重载operator new，那么调用的就是全局的::operator new来完成堆的分配。同理，operator new[]、operator delete、operator delete[]也是可以重载的。

3.如何限制对象只能建立在堆上或者栈上
在C++中，类的对象建立分为两种，一种是静态建立，如A a；另一种是动态建立，如A* ptr=new A；
静态建立一个类对象，是由编译器为对象在栈空间中分配内存，是通过直接移动栈顶指针，挪出适当的空间，然后在这片内存空间上调用构造函数形成一个栈对象。使用这种方法，直接调用类的构造函数。
动态建立类对象，是使用new运算符将对象建立在堆空间中。这个过程分为两步，第一步是执行operator new()函数，在堆空间中搜索合适的内存并进行分配；第二步是调用构造函数构造对象，初始化这片内存空间。这种方法，间接调用类的构造函数。

3.1 只能建立在堆上（设置析构函数为Protected）
类对象只能建立在堆上，就是不能静态建立类对象，即不能直接调用类的构造函数。
容易想到将构造函数设为私有。在构造函数私有之后，无法在类外部调用构造函数来构造类对象，只能使用new运算符来建立对象。然而，前面已经说过，new运算符的执行过程分为两步，C++提供new运算符的重载，其实是只允许重载operator new()函数，而operator()函数用于分配内存，无法提供构造功能。因此，这种方法不可以。
当对象建立在栈上面时，是由编译器分配内存空间的，调用构造函数来构造栈对象。当对象使用完后，编译器会调用析构函数来释放栈对象所占的空间。编译器管理了对象的整个生命周期。如果编译器无法调用类的析构函数，情况会是怎样的呢？比如，类的析构函数是私有的，编译器无法调用析构函数来释放内存。所以，编译器在为类对象分配栈空间时，会先检查类的析构函数的访问性，其实不光是析构函数，只要是非静态的函数，编译器都会进行检查。如果类的析构函数是私有的，则编译器不会在栈空间上为类对象分配内存。
因此，将析构函数设为私有，类对象就无法建立在栈上了。代码如下：

class A  
{  
public:  
    A(){}  
    void destory(){delete this;}  
private:  
    ~A(){}  
};  

 试着使用A a;来建立对象，编译报错，提示析构函数无法访问。这样就只能使用new操作符来建立对象，构造函数是公有的，可以直接调用。类中必须提供一个destory函数，来进行内存空间的释放。类对象使用完成后，必须调用destory函数。
上述方法的一个缺点就是，无法解决继承问题。如果A作为其它类的基类，则析构函数通常要设为virtual，然后在子类重写，以实现多态。因此析构函数不能设为private。还好C++提供了第三种访问控制，protected。将析构函数设为protected可以有效解决这个问题，类外无法访问protected成员，子类则可以访问。
另一个问题是，类的使用很不方便，使用new建立对象，却使用destory函数释放对象，而不是使用delete。（使用delete会报错，因为delete对象的指针，会调用对象的析构函数，而析构函数类外不可访问）这种使用方式比较怪异。为了统一，可以将构造函数设为protected，然后提供一个public的static函数来完成构造，这样不使用new，而是使用一个函数来构造，使用一个函数来析构。代码如下，类似于单例模式：

class A  
{  
protected:  
    A(){}  
    ~A(){}  
public:  
    static A* create()  
    {  
        return new A();  
    }  
    void destory()  
    {  
        delete this;  
    }  
};  

这样，调用create()函数在堆上创建类A对象，调用destory()函数释放内存。

3.2 只能建立在栈上(重载new函数设为私有)
只有使用new运算符，对象才会建立在堆上，因此，只要禁用new运算符就可以实现类对象只能建立在栈上。将operator new()设为私有即可。代码如下：

class A  
{  
private:  
    void* operator new(size_t t){}     // 注意函数的第一个参数和返回值都是固定的  
    void operator delete(void* ptr){}  // 重载了new就需要重载delete  
public:  
    A(){}  
    ~A(){}  
};
